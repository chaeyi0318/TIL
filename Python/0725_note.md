## 상속 (Inheritance)
- 기존 클래스의 속성과 메서드를 **모두** 물려받아 새로운 하위 클래스를 생성하는 것

### 상속이 필요한 이유
1. 코드 재사용
- 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
- 새로운 클래스를 작성할 때 기존 클래스의 기능을 그대로 활용할 수 있으며, 중복된 코드를 줄일 수 있음
2. 계층 구조
- 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
- 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음
3. 유지보수의 용이성
- 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
- 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화할 수 있음

**상속 없이 구현하는 경우 메서드가 중복으로 정의될 수 있음**

### 다중 상속
- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있는 것
- 상속 받은 모든 클래스의 요소를 활용 가능함
> **중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정됨**
```python
class Child(Dad, Mom):
    pass        
# 우선 순위는 1. Dad 2. Mom
```

### 다이아몬드 문제(The diamond problem)
- 작성 ㄱㄱ
- 파이썬의 해결책

### mro()

## 디버깅
### 버그
- 소프트웨에서 발생하는 오류 또는 결함
- 프로그램의 예상된 동작과 실제 동작 사이의 불일치

### 디버깅
- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정
- 프로그램의 오작동 원인을 식별하여 수정하는 작업

### 에러 유형
- 문법 에러 (Syntax Error)
    - 프로그램의 구문이 올바르지 않은 경우 발생

- 예외 (Exceoption)
    - 프로그램 실행 중 감지되는 에러

### 예외
- 내장 예외(Built-in Exceptions) : 예외 상황을 나타내는 예외 클래스들

### 예외처리 사용 구문
- try : 예외가 발생할 수 있는 코드 작성
- except : 예외가 발생했을 때 실행할 코드 작성
- else : 예외가 발생하지 않았을 때 실행할 코드 작성
- finally : 예외 발생 여부와 상관없이 항상 실행할 코드 작성

### 예외 객체 다루기
- as 키워드
    - 예외객체 : 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
    - except 블록에서 예외 객체를 받아 상세한 예외 정보를 활용 가능

### 예외처리와 값 검사에 대한 2가지 접근 방식
#### EAFP : 예외처리를 중심으로 코드를 작성하는 접근 방식 (try-except)
#### LBYL : 값 검사를 중심으로 코드를 작성하는 접근 방식 (if-else)

```python
# EAFP
try:
    result = my_dict['key']
    print(result)
except KeyError:
    print('key가 존재하지 않습니다.')

# LBYL
if 'key' in my_dict:
    result = my_dict['key']
    print(result)
else:
    print('key가 존재하지 않습니다')
```

#### 접근 방식 비교
- 작성